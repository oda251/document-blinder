var background=function(){"use strict";var Se=Object.defineProperty;var Ie=(K,V,M)=>V in K?Se(K,V,{enumerable:!0,configurable:!0,writable:!0,value:M}):K[V]=M;var v=(K,V,M)=>Ie(K,typeof V!="symbol"?V+"":V,M);var R,B,N,Q;function K(r){return r==null||typeof r=="function"?{main:r}:r}var V=Object.prototype.hasOwnProperty;function M(r,e){var i,c;if(r===e)return!0;if(r&&e&&(i=r.constructor)===e.constructor){if(i===Date)return r.getTime()===e.getTime();if(i===RegExp)return r.toString()===e.toString();if(i===Array){if((c=r.length)===e.length)for(;c--&&M(r[c],e[c]););return c===-1}if(!i||typeof r=="object"){c=0;for(i in r)if(V.call(r,i)&&++c&&!V.call(e,i)||!(i in e)||!M(r[i],e[i]))return!1;return Object.keys(e).length===c}}return r!==r&&e!==e}const Z=new Error("request for lock canceled");var ee=function(r,e,i,c){function d(u){return u instanceof i?u:new i(function(f){f(u)})}return new(i||(i=Promise))(function(u,f){function S(p){try{x(c.next(p))}catch(A){f(A)}}function H(p){try{x(c.throw(p))}catch(A){f(A)}}function x(p){p.done?u(p.value):d(p.value).then(S,H)}x((c=c.apply(r,e||[])).next())})};class te{constructor(e,i=Z){this._value=e,this._cancelError=i,this._queue=[],this._weightedWaiters=[]}acquire(e=1,i=0){if(e<=0)throw new Error(`invalid weight ${e}: must be positive`);return new Promise((c,d)=>{const u={resolve:c,reject:d,weight:e,priority:i},f=U(this._queue,S=>i<=S.priority);f===-1&&e<=this._value?this._dispatchItem(u):this._queue.splice(f+1,0,u)})}runExclusive(e){return ee(this,arguments,void 0,function*(i,c=1,d=0){const[u,f]=yield this.acquire(c,d);try{return yield i(u)}finally{f()}})}waitForUnlock(e=1,i=0){if(e<=0)throw new Error(`invalid weight ${e}: must be positive`);return this._couldLockImmediately(e,i)?Promise.resolve():new Promise(c=>{this._weightedWaiters[e-1]||(this._weightedWaiters[e-1]=[]),ae(this._weightedWaiters[e-1],{resolve:c,priority:i})})}isLocked(){return this._value<=0}getValue(){return this._value}setValue(e){this._value=e,this._dispatchQueue()}release(e=1){if(e<=0)throw new Error(`invalid weight ${e}: must be positive`);this._value+=e,this._dispatchQueue()}cancel(){this._queue.forEach(e=>e.reject(this._cancelError)),this._queue=[]}_dispatchQueue(){for(this._drainUnlockWaiters();this._queue.length>0&&this._queue[0].weight<=this._value;)this._dispatchItem(this._queue.shift()),this._drainUnlockWaiters()}_dispatchItem(e){const i=this._value;this._value-=e.weight,e.resolve([i,this._newReleaser(e.weight)])}_newReleaser(e){let i=!1;return()=>{i||(i=!0,this.release(e))}}_drainUnlockWaiters(){if(this._queue.length===0)for(let e=this._value;e>0;e--){const i=this._weightedWaiters[e-1];i&&(i.forEach(c=>c.resolve()),this._weightedWaiters[e-1]=[])}else{const e=this._queue[0].priority;for(let i=this._value;i>0;i--){const c=this._weightedWaiters[i-1];if(!c)continue;const d=c.findIndex(u=>u.priority<=e);(d===-1?c:c.splice(0,d)).forEach(u=>u.resolve())}}}_couldLockImmediately(e,i){return(this._queue.length===0||this._queue[0].priority<i)&&e<=this._value}}function ae(r,e){const i=U(r,c=>e.priority<=c.priority);r.splice(i+1,0,e)}function U(r,e){for(let i=r.length-1;i>=0;i--)if(e(r[i]))return i;return-1}var ie=function(r,e,i,c){function d(u){return u instanceof i?u:new i(function(f){f(u)})}return new(i||(i=Promise))(function(u,f){function S(p){try{x(c.next(p))}catch(A){f(A)}}function H(p){try{x(c.throw(p))}catch(A){f(A)}}function x(p){p.done?u(p.value):d(p.value).then(S,H)}x((c=c.apply(r,e||[])).next())})};class re{constructor(e){this._semaphore=new te(1,e)}acquire(){return ie(this,arguments,void 0,function*(e=0){const[,i]=yield this._semaphore.acquire(1,e);return i})}runExclusive(e,i=0){return this._semaphore.runExclusive(()=>e(),1,i)}isLocked(){return this._semaphore.isLocked()}waitForUnlock(e=0){return this._semaphore.waitForUnlock(1,e)}release(){this._semaphore.isLocked()&&this._semaphore.release()}cancel(){return this._semaphore.cancel()}}const j=((B=(R=globalThis.browser)==null?void 0:R.runtime)==null?void 0:B.id)==null?globalThis.chrome:globalThis.browser,I=se();function se(){const r={local:C("local"),session:C("session"),sync:C("sync"),managed:C("managed")},e=n=>{const a=r[n];if(a==null){const t=Object.keys(r).join(", ");throw Error(`Invalid area "${n}". Options: ${t}`)}return a},i=n=>{const a=n.indexOf(":"),t=n.substring(0,a),s=n.substring(a+1);if(s==null)throw Error(`Storage key should be in the form of "area:key", but received "${n}"`);return{driverArea:t,driverKey:s,driver:e(t)}},c=n=>n+"$",d=(n,a)=>{const t={...n};return Object.entries(a).forEach(([s,o])=>{o==null?delete t[s]:t[s]=o}),t},u=(n,a)=>n??a??null,f=n=>typeof n=="object"&&!Array.isArray(n)?n:{},S=async(n,a,t)=>{const s=await n.getItem(a);return u(s,(t==null?void 0:t.fallback)??(t==null?void 0:t.defaultValue))},H=async(n,a)=>{const t=c(a),s=await n.getItem(t);return f(s)},x=async(n,a,t)=>{await n.setItem(a,t??null)},p=async(n,a,t)=>{const s=c(a),o=f(await n.getItem(s));await n.setItem(s,d(o,t))},A=async(n,a,t)=>{if(await n.removeItem(a),t!=null&&t.removeMeta){const s=c(a);await n.removeItem(s)}},Y=async(n,a,t)=>{const s=c(a);if(t==null)await n.removeItem(s);else{const o=f(await n.getItem(s));[t].flat().forEach(l=>delete o[l]),await n.setItem(s,o)}},J=(n,a,t)=>n.watch(a,t);return{getItem:async(n,a)=>{const{driver:t,driverKey:s}=i(n);return await S(t,s,a)},getItems:async n=>{const a=new Map,t=new Map,s=[];n.forEach(l=>{let m,h;typeof l=="string"?m=l:"getValue"in l?(m=l.key,h={fallback:l.fallback}):(m=l.key,h=l.options),s.push(m);const{driverArea:k,driverKey:z}=i(m),_=a.get(k)??[];a.set(k,_.concat(z)),t.set(m,h)});const o=new Map;return await Promise.all(Array.from(a.entries()).map(async([l,m])=>{(await r[l].getItems(m)).forEach(k=>{const z=`${l}:${k.key}`,_=t.get(z),w=u(k.value,(_==null?void 0:_.fallback)??(_==null?void 0:_.defaultValue));o.set(z,w)})})),s.map(l=>({key:l,value:o.get(l)}))},getMeta:async n=>{const{driver:a,driverKey:t}=i(n);return await H(a,t)},getMetas:async n=>{const a=n.map(o=>{const l=typeof o=="string"?o:o.key,{driverArea:m,driverKey:h}=i(l);return{key:l,driverArea:m,driverKey:h,driverMetaKey:c(h)}}),t=a.reduce((o,l)=>{var m;return o[m=l.driverArea]??(o[m]=[]),o[l.driverArea].push(l),o},{}),s={};return await Promise.all(Object.entries(t).map(async([o,l])=>{const m=await j.storage[o].get(l.map(h=>h.driverMetaKey));l.forEach(h=>{s[h.key]=m[h.driverMetaKey]??{}})})),a.map(o=>({key:o.key,meta:s[o.key]}))},setItem:async(n,a)=>{const{driver:t,driverKey:s}=i(n);await x(t,s,a)},setItems:async n=>{const a={};n.forEach(t=>{const{driverArea:s,driverKey:o}=i("key"in t?t.key:t.item.key);a[s]??(a[s]=[]),a[s].push({key:o,value:t.value})}),await Promise.all(Object.entries(a).map(async([t,s])=>{await e(t).setItems(s)}))},setMeta:async(n,a)=>{const{driver:t,driverKey:s}=i(n);await p(t,s,a)},setMetas:async n=>{const a={};n.forEach(t=>{const{driverArea:s,driverKey:o}=i("key"in t?t.key:t.item.key);a[s]??(a[s]=[]),a[s].push({key:o,properties:t.meta})}),await Promise.all(Object.entries(a).map(async([t,s])=>{const o=e(t),l=s.map(({key:z})=>c(z));console.log(t,l);const m=await o.getItems(l),h=Object.fromEntries(m.map(({key:z,value:_})=>[z,f(_)])),k=s.map(({key:z,properties:_})=>{const w=c(z);return{key:w,value:d(h[w]??{},_)}});await o.setItems(k)}))},removeItem:async(n,a)=>{const{driver:t,driverKey:s}=i(n);await A(t,s,a)},removeItems:async n=>{const a={};n.forEach(t=>{let s,o;typeof t=="string"?s=t:"getValue"in t?s=t.key:"item"in t?(s=t.item.key,o=t.options):(s=t.key,o=t.options);const{driverArea:l,driverKey:m}=i(s);a[l]??(a[l]=[]),a[l].push(m),o!=null&&o.removeMeta&&a[l].push(c(m))}),await Promise.all(Object.entries(a).map(async([t,s])=>{await e(t).removeItems(s)}))},removeMeta:async(n,a)=>{const{driver:t,driverKey:s}=i(n);await Y(t,s,a)},snapshot:async(n,a)=>{var o;const s=await e(n).snapshot();return(o=a==null?void 0:a.excludeKeys)==null||o.forEach(l=>{delete s[l],delete s[c(l)]}),s},restoreSnapshot:async(n,a)=>{await e(n).restoreSnapshot(a)},watch:(n,a)=>{const{driver:t,driverKey:s}=i(n);return J(t,s,a)},unwatch(){Object.values(r).forEach(n=>{n.unwatch()})},defineItem:(n,a)=>{const{driver:t,driverKey:s}=i(n),{version:o=1,migrations:l={}}=a??{};if(o<1)throw Error("Storage item version cannot be less than 1. Initial versions should be set to 1, not 0.");const m=async()=>{var X;const w=c(s),[{value:$},{value:O}]=await t.getItems([s,w]);if($==null)return;const q=(O==null?void 0:O.v)??1;if(q>o)throw Error(`Version downgrade detected (v${q} -> v${o}) for "${n}"`);console.debug(`[@wxt-dev/storage] Running storage migration for ${n}: v${q} -> v${o}`);const pe=Array.from({length:o-q},(F,G)=>q+G+1);let L=$;for(const F of pe)try{L=await((X=l==null?void 0:l[F])==null?void 0:X.call(l,L))??L}catch(G){throw Error(`v${F} migration failed for "${n}"`,{cause:G})}await t.setItems([{key:s,value:L},{key:w,value:{...O,v:o}}]),console.debug(`[@wxt-dev/storage] Storage migration completed for ${n} v${o}`,{migratedValue:L})},h=(a==null?void 0:a.migrations)==null?Promise.resolve():m().catch(w=>{console.error(`[@wxt-dev/storage] Migration failed for ${n}`,w)}),k=new re,z=()=>(a==null?void 0:a.fallback)??(a==null?void 0:a.defaultValue)??null,_=()=>k.runExclusive(async()=>{const w=await t.getItem(s);if(w!=null||(a==null?void 0:a.init)==null)return w;const $=await a.init();return await t.setItem(s,$),$});return h.then(_),{key:n,get defaultValue(){return z()},get fallback(){return z()},getValue:async()=>(await h,a!=null&&a.init?await _():await S(t,s,a)),getMeta:async()=>(await h,await H(t,s)),setValue:async w=>(await h,await x(t,s,w)),setMeta:async w=>(await h,await p(t,s,w)),removeValue:async w=>(await h,await A(t,s,w)),removeMeta:async w=>(await h,await Y(t,s,w)),watch:w=>J(t,s,($,O)=>w($??z(),O??z())),migrate:m}}}}function C(r){const e=()=>{if(j.runtime==null)throw Error(["'wxt/storage' must be loaded in a web extension environment",`
 - If thrown during a build, see https://github.com/wxt-dev/wxt/issues/371`,` - If thrown during tests, mock 'wxt/browser' correctly. See https://wxt.dev/guide/go-further/testing.html
`].join(`
`));if(j.storage==null)throw Error("You must add the 'storage' permission to your manifest to use 'wxt/storage'");const c=j.storage[r];if(c==null)throw Error(`"browser.storage.${r}" is undefined`);return c},i=new Set;return{getItem:async c=>(await e().get(c))[c],getItems:async c=>{const d=await e().get(c);return c.map(u=>({key:u,value:d[u]??null}))},setItem:async(c,d)=>{d==null?await e().remove(c):await e().set({[c]:d})},setItems:async c=>{const d=c.reduce((u,{key:f,value:S})=>(u[f]=S,u),{});await e().set(d)},removeItem:async c=>{await e().remove(c)},removeItems:async c=>{await e().remove(c)},snapshot:async()=>await e().get(),restoreSnapshot:async c=>{await e().set(c)},watch(c,d){const u=f=>{const S=f[c];S!=null&&(M(S.newValue,S.oldValue)||d(S.newValue??null,S.oldValue??null))};return e().onChanged.addListener(u),i.add(u),()=>{e().onChanged.removeListener(u),i.delete(u)}},unwatch(){i.forEach(c=>{e().onChanged.removeListener(c)}),i.clear()}}}const g={isActivated:{default:!0,fallback:!1},isHorizontal:{default:!0,fallback:!0},spaceSize:{default:5,fallback:5,min:1,max:{default:20,fallback:20,min:1,max:20}},opacity:{default:.5,fallback:.5}};class ne{constructor(){v(this,"storage",I.defineItem("local:isActivated",{defaultValue:g.isActivated.default,fallback:g.isActivated.fallback}))}async getValue(){return await I.getItem("local:isActivated")??g.isActivated.default}async setValue(e){await I.setItem("local:isActivated",e)}}class ce{constructor(){v(this,"storage",I.defineItem("local:isHorizontal",{defaultValue:g.isHorizontal.default,fallback:g.isHorizontal.fallback}))}async getValue(){return await I.getItem("local:isHorizontal")??g.isHorizontal.default}async setValue(e){await I.setItem("local:isHorizontal",e)}}class oe{constructor(){v(this,"storage",I.defineItem("local:spaceSize",{defaultValue:g.spaceSize.default,fallback:g.spaceSize.fallback}))}async getValue(){return await I.getItem("local:spaceSize")??g.spaceSize.default}async setValue(e){await I.setItem("local:spaceSize",e)}}class le{constructor(){v(this,"storage",I.defineItem("local:maxSpaceSize",{defaultValue:g.spaceSize.max.default,fallback:g.spaceSize.max.fallback}))}async getValue(){return await I.getItem("local:maxSpaceSize")??g.spaceSize.max.default}async setValue(e){await I.setItem("local:maxSpaceSize",e)}}class ue{constructor(){v(this,"storage",I.defineItem("local:opacity",{defaultValue:g.opacity.default,fallback:g.opacity.fallback}))}async getValue(){return await I.getItem("local:opacity")??g.opacity.default}async setValue(e){await I.setItem("local:opacity",e)}}class de{constructor(){v(this,"IsActivated",new ne);v(this,"IsHorizontal",new ce);v(this,"SpaceSize",new oe);v(this,"MaxSpaceSize",new le);v(this,"Opacity",new ue)}async getAll(){const e=await Promise.all([this.IsActivated.getValue(),this.IsHorizontal.getValue(),this.SpaceSize.getValue(),this.MaxSpaceSize.getValue(),this.Opacity.getValue()]);return{isActivated:e[0],isHorizontal:e[1],spaceSize:e[2],maxSpaceSize:e[3],opacity:e[4]}}}const E=new de,fe={isActivated:g.isActivated.default,isHorizontal:g.isHorizontal.default,spaceSize:g.spaceSize.default,maxSpaceSize:g.spaceSize.max.default,opacity:g.opacity.default},D="DBlinder";class T{constructor(e){v(this,"namespace");v(this,"GET");v(this,"SET");v(this,"CALL");this.namespace=`${D}:${e}`,this.GET=this.format("GET"),this.SET=this.format("SET"),this.CALL=this.format("CALL")}format(e){return`${this.namespace}:${e}`}}class y{}v(y,"isActivated",new T("is-activated")),v(y,"isHorizontal",new T("is-horizontal")),v(y,"spaceSize",new T("space-size")),v(y,"maxSpaceSize",new T("max-space-size")),v(y,"opacity",new T("opacity")),v(y,"config",new T("config")),v(y,"updateBlinds",new T("update-blinds"));const me=r=>r.startsWith(D);let b=fe;const he=async()=>{b=await E.getAll()},we=r=>r===y.config.GET?b:r===y.isActivated.GET?b.isActivated:r===y.isHorizontal.GET?b.isHorizontal:r===y.spaceSize.GET?b.spaceSize:r===y.maxSpaceSize.GET?b.maxSpaceSize:r===y.opacity.GET?b.opacity:void 0,ve=async(r,e)=>{if(r===y.config.SET){const i=[E.IsActivated.setValue(e.isActivated),E.IsHorizontal.setValue(e.isHorizontal),E.SpaceSize.setValue(e.spaceSize),E.MaxSpaceSize.setValue(e.maxSpaceSize),E.Opacity.setValue(e.opacity)];await Promise.all(i),b=e}else if(r===y.isActivated.SET)await E.IsActivated.setValue(e),b.isActivated=e;else if(r===y.isHorizontal.SET)await E.IsHorizontal.setValue(e),b.isHorizontal=e;else if(r===y.spaceSize.SET)await E.SpaceSize.setValue(e),b.spaceSize=e;else if(r===y.maxSpaceSize.SET)await E.MaxSpaceSize.setValue(e),b.maxSpaceSize=e;else if(r===y.opacity.SET)await E.Opacity.setValue(e),b.opacity=e;else return},ge=K({main:async()=>{await he(),chrome.runtime.onMessage.addListener((r,e,i)=>{if(me(r.type)){let c=we(r.type)||ve(r.type,r.value);i(c)}})}});function Ve(){}((Q=(N=globalThis.browser)==null?void 0:N.runtime)==null?void 0:Q.id)==null?globalThis.chrome:globalThis.browser;function P(r,...e){}const ye={debug:(...r)=>P(console.debug,...r),log:(...r)=>P(console.log,...r),warn:(...r)=>P(console.warn,...r),error:(...r)=>P(console.error,...r)};let W;try{W=ge.main(),W instanceof Promise&&console.warn("The background's main() function return a promise, but it must be synchronous")}catch(r){throw ye.error("The background crashed on startup!"),r}return W}();
background;
